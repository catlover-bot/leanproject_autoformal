import Mathlib.Data.Real.Basic
import Mathlib.Data.Rat.Basic

theorem rational_linear_combination_zero
  (a b c : ℚ) (m n : ℝ) (h_pos : 0 < m ∧ 0 < n)
  (hm : m^3 = 2) (hn : n^3 = 4)
  (h_eq : (a:ℝ) + b * m + c * n = 0) : a = 0 ∧ b = 0 ∧ c = 0 :=
begin
  have h_m_irrational : ¬ is_rat m,
  { intro h,
    obtain ⟨q, hq⟩ := h,
    have : (q : ℝ)^3 = 2 := by rw [← hq, hm],
    have : (q^3 : ℝ) = 2 := by exact_mod_cast this,
    have : (q^3 : ℚ) = 2 := by exact_mod_cast this,
    have : q^3 = 2 := by exact_mod_cast this,
    have : q^3 - 2 = 0 := by rw [this, sub_self],
    have : (q - 2^(1/3)) * (q^2 + q * 2^(1/3) + (2^(1/3))^2) = 0,
    { rw [← sub_eq_zero, ← this],
      ring },
    cases mul_eq_zero.mp this with h1 h2,
    { have : q = 2^(1/3) := by exact_mod_cast h1,
      have : is_rat (2^(1/3)) := ⟨q, this.symm⟩,
      have : ¬ is_rat (2^(1/3)) := by norm_num,
      contradiction },
    { have : q^2 + q * 2^(1/3) + (2^(1/3))^2 = 0 := by exact_mod_cast h2,
      have : is_rat (q^2 + q * 2^(1/3) + (2^(1/3))^2) := by norm_cast,
      have : ¬ is_rat (q^2 + q * 2^(1/3) + (2^(1/3))^2) := by norm_num,
      contradiction } },
  have h_n_irrational : ¬ is_rat n,
  { intro h,
    obtain ⟨q, hq⟩ := h,
    have : (q : ℝ)^3 = 4 := by rw [← hq, hn],
    have : (q^3 : ℝ) = 4 := by exact_mod_cast this,
    have : (q^3 : ℚ) = 4 := by exact_mod_cast this,
    have : q^3 = 4 := by exact_mod_cast this,
    have : q^3 - 4 = 0 := by rw [this, sub_self],
    have : (q - 4^(1/3)) * (q^2 + q * 4^(1/3) + (4^(1/3))^2) = 0,
    { rw [← sub_eq_zero, ← this],
      ring },
    cases mul_eq_zero.mp this with h1 h2,
    { have : q = 4^(1/3) := by exact_mod_cast h1,
      have : is_rat (4^(1/3)) := ⟨q, this.symm⟩,
      have : ¬ is_rat (4^(1/3)) := by norm_num,
      contradiction },
    { have : q^2 + q * 4^(1/3) + (4^(1/3))^2 = 0 := by exact_mod_cast h2,
      have : is_rat (q^2 + q * 4^(1/3) + (4^(1/3))^2) := by norm_cast,
      have : ¬ is_rat (q^2 + q * 4^(1/3) + (4^(1/3))^2) := by norm_num,
      contradiction } },
  have h_rational : is_rat ((a:ℝ) + b * m + c * n),
  { exact ⟨a + b * (m:ℚ) + c * (n:ℚ), by norm_cast⟩ },
  have : (a:ℝ) + b * m + c * n ≠ 0,
  { intro h,
    rw h_eq at h,
    exact h },
  contradiction,
end